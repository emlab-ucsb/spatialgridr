% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/get_data_in_grid.R
\name{get_data_in_grid}
\alias{get_data_in_grid}
\title{Get gridded or cropped data from input data}
\usage{
get_data_in_grid(
  area_polygon = NULL,
  spatial_grid = NULL,
  dat = NULL,
  meth = NULL,
  name = NULL,
  feature_names = NULL,
  antimeridian = NULL,
  cutoff = 0.5,
  apply_cutoff = TRUE
)
}
\arguments{
\item{area_polygon}{\code{sf} polygon}

\item{spatial_grid}{\code{sf} or \code{terra::rast()} planning grid}

\item{dat}{\code{sf} or \code{terra::rast()} data to be gridded/ cropped}

\item{meth}{\code{character} method to use for for gridding/ resampling/ reprojecting raster data. If NULL (default), function checks if data values are binary (all 0, 1, NA, or NaN) in which case method is set to "mode" for sf output or "near" for raster output. If data is non-binary, method is set to "average" for sf output or "mean" for raster output. Note that different methods are used for sf and raster as \code{exactextractr::exact_extract()} is used for gridding to sf planning grid, whereas \code{terra::project()}/\code{terra::resample()} is used for transforming/ gridding raster data.}

\item{name}{\code{character} to name the data output; unless \code{feature_names} is supplied, in which case that column is used as the feature names}

\item{feature_names}{\code{character} (\code{sf} data only) column with feature names that will be used for grouping of input data. If NULL, \code{sf} data is assumed to represent a single features, e.g. one habitat or species.}

\item{antimeridian}{\code{logical} can be set to true if the data to be extracted crosses the antimeridian and is in lon-lat (EPSG:4326) format. If set to \code{NULL} (default) the function will try to check if data spans the antimeridian and set this appropriately.}

\item{cutoff}{\code{numeric} (\code{sf} data only) cover fraction value between 0 and 1; if gridded output is required (i.e. a \code{spatial_grid} is provided), how much of each grid cell should be covered by an sf feature for it to be classified as that feature type}

\item{apply_cutoff}{\code{logical} (\code{sf} data only) if gridded output is required (i.e. a \code{spatial_grid} is provided), \code{FALSE} will return an \code{sf} object with the \% coverage of each feature in each grid cell, as opposed to a binary presence/ absence. \code{feature_names} should be provided.}
}
\value{
\code{sf} or \code{terra::rast()} object; cropped and intersected data in same format as \code{dat} if  an \code{area_polygon} is provided, otherwise \code{sf} or \code{terra::rast()} gridded data depending on the format of the planning grid provided
}
\description{
Get gridded or cropped data from input data
}
\examples{
# ridges data for area of Pacific
ridges <- system.file("extdata", "ridges.rds", package = "spatialgridr") |> readRDS()
# an area of interest, in this case Samoa's Exclusive Economic Zone
samoa_eez <- system.file("extdata", "samoa_eez.rds", package = "spatialgridr") |> readRDS()

# You need a suitable projection for your area of interest, https://projectionwizard.org is useful for this purpose. For spatial planning, equal area projections are normally best.
samoa_projection <- '+proj=laea +lon_0=-172.5 +lat_0=0 +datum=WGS84 +units=m +no_defs'

# Create a planning grid with 5km sized planning units
planning_grid <- get_grid(area_polygon = samoa_eez, projection_crs = samoa_projection, resolution = 5000)
# Get ridges data, which is vector data in sf format, in the planning grid
ridges_gridded <- get_data_in_grid(spatial_grid = planning_grid, dat = ridges)
terra::plot(ridges_gridded)

#Get some raster data on cold water corals for the same planning grid
cold_coral <- system.file("extdata", "cold_coral.tif", package = "spatialgridr") |> terra::rast()
coral_gridded <- get_data_in_grid(spatial_grid = planning_grid, dat = cold_coral)
terra::plot(coral_gridded)
}
